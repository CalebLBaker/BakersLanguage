/**
@summary
This header is automatically included by the compiler and contains implementations that the
compiler assumes to be present during compilation. It should never be necessary to explicitly
include it.
*/

/**
@summary signed integer
*/
Type sint = sint64;

/**
@summary unsigned integer
*/
Type uint = uint64;

/**
@summary 8 bit integer
*/
Type int8 = sint8;

/**
@summary 16 bit integer
*/
Type int16 = sint16;

/**
@summary 32 bit integer
*/
Type int32 = sint32;

/**
@summary 64 bit integer
*/
Type int64 = sint64;

/**
@summary integer
*/
Type int = sint;

/**
@summary primitive the same size as the smallest addressable unit of memory
*/
typedef uint8 byte;

/**
@summary rune is a type used to represents a unicode code point
*/
typedef uint32 rune;

/**
@summary bool can hold boolean (true/false) values
*/
typedef uint8 bool;

/**
@summary
Assignable provides an interface for types that can have values assigned to them using the =
operator
@param ValueType the type of value that can be assigned
@returns the interface
*/
func(Type ValueType) -> interface Assignable = interface {

	/**
	@summary assign assigns the a new value to this. This function is used by the = operator.
	@param value the value to assign to this
	*/
	func [&Self](ValueType value) assign;

	// func [&Self](ValueType value) operator= { assign(value); }
}


/**
@summary 
Incrementable provides an interface for types that can be incremented using the ++ operator.
*/
interface Incrementable {

	/**
	@summary
	increment advances the variable to the next value. This is the function that is called by the
	++ operator.
	*/
	func [&Self]() increment;

	// func [&Self]() operator++ { increment(); }
}


/**
@summary 
Decrementable provides an interface for types that can be decremented using the -- operator.
*/
interface Decrementable {

	/**
	@summary
	decrement moves the variable back to the value that is one lower than its current value.
	This is the function that is called by the -- operator.
	*/
	func [&Self]() decrement;

	// func [&Self]() operator-- { decrement(); }
}


/**
@summary
Addable provides an interface for types that can be added to other types using the + operator.
@param Other
The type that can be added to the type implementing the interface
@returns the interface
*/
func(Type Other) -> interface Addable = interface {
	implements Assignable(Self);

	/**
	@summary add adds two values together and returns the sum. It is used by the + operator.
	@param lhs one operand to add
	@param rhs the other operand to add
	@returns the sum of lhs and rhs
	*/
	func(Self lhs, Other rhs) -> Self add;

	/**
	@summary add adds two values together and returns the sum. It is used by the + operator.
	@param lhs one operand to add
	@param rhs the other operand to add
	@returns the sum of lhs and rhs
	*/
	overload func(Other lhs, Self rhs) -> Self add = add(rhs, lhs);

	// func(Self lhs, Other rhs) -> Self operator+ = add(lhs, rhs);
	// func(Other lhs, Self rhs) -> Self operator+ = add(lhs, rhs);

	/**
	@summary add adds another value to this, changing the value of this
	@param rhs the value to add to this
	*/
	overload func[&Self](Other rhs) add {
		*this = *this + rhs;
	}

	// func[&Self](Other rhs) operator+= { add(rhs); }
}


/**
@summary
Subtractable provides an interface for types that can have other types subtracted from them using
the - operator
@param Other
The type that can be subtracted from self
@param Difference
The type of the result of the subtraction
@returns the interface
*/
func(Type Other, Type Difference) -> interface Subtractable = interface {
	
	/**
	@summary subtract subtracts one value from another. It is used by the - operator.
	@param lhs The value to subtract from
	@param rhs The value to subtract
	@returns The difference between lhs and rhs
	*/
	func(Self lhs, Other rhs) -> Difference subtract;

	// func(Self lhs, Other rhs) -> Difference operator- = subtract(lhs, rhs);
}


/**
@summary
Comparable provides an interface for types that can be compared using the == and != operators
@param Other the type that can be compared to types implementing the interface
@returns the interface
*/
func(Type Other) -> interface Comparable = interface {

	/**
	@summary
	equal compares two values and checks if they are equal. This function is called by the ==
	operator
	@param lhs one value to compare
	@param rhs the other value to compare
	@returns true if lhs and rhs are equal
	*/
	func(Self lhs, Other rhs) -> bool equal;

	/**
	@summary
	equal compares two values and checks if they are equal. This function is called by the ==
	operator
	@param lhs one value to compare
	@param rhs the other value to compare
	@returns true if lhs and rhs are equal
	*/
	overload func(Other lhs, Self rhs) -> bool equal = equal(rhs, lhs);

	/**
	@summary
	notEqual compares two values and checks if the are not equal. This function is called by the !=
	operator
	@param lhs one value to compare
	@param rhs the other value to compare
	@returns true if lhs and rhs are not equal
	*/
	overload func(Self lhs, Other rhs) -> bool notEqual = !equal(lhs, rhs);

	/**
	@summary
	notEqual compares two values and checks if the are not equal. This function is called by the !=
	operator
	@param lhs one value to compare
	@param rhs the other value to compare
	@returns true if lhs and rhs are not equal
	*/
	overload func(Other lhs, Self rhs) -> bool notEqual = notEqual(rhs, lhs);

	// func(Self lhs, Other rhs) -> bool operator== = equal(lhs, rhs);
	// func(Other lhs, Self rhs) -> bool operator== = equal(lhs, rhs);
	// func(Self lhs, Other rhs) -> bool operator!= = notEqual(lhs, rhs);
	// func(Other lhs, Self rhs) -> bool operator!= = notEqual(lhs, rhs);
}


/**
@summary
Dereferencable provides an interface for types that can be dereferenced using the unary * operator.
@param ValueType the type of value obtained by dereferencing
@returns the interface
*/
func(Type ValueType) -> interface Dereferencable = interface {

	/**
	@summary
	ptr retrieves the address of the value referenced by the variable. This function is used in the
	implementation of the unary * operator.
	@returns the address of the value acheived by dereferencing
	*/
	func [Self]() -> &ValueType ptr;

	// func [&Self]() operator* -> ValueType { return *ptr(); }
}


/**
@summary Error provides an interface for types that represent errors
*/
interface Error {

	/**
	@summary
	ok checks whether the error indicates success or failure. This function is used by the try
	construct.
	@returns
	true if the error indicates success
	*/
	func[Self]() -> bool ok;
}


/**
@summary
Slice is a type that represents an array or part of an array. It references the memory that its
data is stored in but it does not own the memory. The memory could be on the stack, on the heap, or
in read-only memory. It does not matter to the slice where the memory it references is.
@param
ValueType the type of data stored in the slice
*/
func(Type ValueType) -> Type Slice = class {
	private &ValueType mpStart;
	private &ValueType mpEnd;

	/**
	@summary This constructor constructs a slice that references a buffer of a given size
	@param ptr A pointer to the start of the buffer
	@param size The number of elements in the buffer
	*/
	func(&ValueType ptr, uint size) {
		mpStart = ptr;
		mpEnd = ptr + size;
	}

	/**
	@summary begin retrieves a pointer to the start of the slice's memory
	@returns a pointer to the start of the slice
	*/
	func() -> &ValueType begin() = mpStart;

	/**
	@summary end retrieves a pointer to one past the end of the slice's memory
	@returns a pointer to one past the end of the slice
	*/
	func() -> &ValueType end() = mpEnd;
}


// func(Type ValueType) -> Type operator[] = Slice(ValueType;

